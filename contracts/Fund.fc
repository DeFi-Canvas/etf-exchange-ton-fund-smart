#include "imports/stdlib.fc";
#include "imports/params.fc";
#include "imports/op-codes.fc";
#include "imports/discovery-params.fc";
#include "imports/jetton-utils.fc"; 
#include "imports/fund_utils.fc"; 
#include "imports/messages.fc";

int provide_address_gas_consumption() asm "10000000 PUSHINT";

global slice storage::admin;
global cell storage::jettons_data;
global cell storage::storage::content;
global cell storage::liquidity_manager_code;
global cell storage::liquidity_helper_code;

() load_data() impure {
    slice ds = get_data().begin_parse();
    storage::admin = ds~load_msg_addr(); ;; storage::admin
    storage::jettons_data = ds~load_dict(); ;; total_supply
    
    storage::storage::content = ds~load_ref(); ;; storage::content
    storage::liquidity_manager_code = ds~load_ref(); ;; liquidity_manager_code
    storage::liquidity_helper_code = ds~load_ref();
}

() save_data() impure inline {
    set_data(begin_cell()
            .store_slice(storage::admin)
            .store_dict(storage::jettons_data)
            .store_ref(storage::storage::content)
            .store_ref(storage::liquidity_manager_code)
            .store_ref(storage::liquidity_helper_code)
            .end_cell()
    );
}

() mint_tokens(slice to_address, cell storage::liquidity_manager_code, int amount, cell master_msg) impure {
    cell state_init = calculate_jetton_wallet_state_init(to_address, my_address(), storage::jettons_data, storage::liquidity_manager_code);
    slice to_wallet_address = calculate_jetton_wallet_address(state_init);
    var msg = begin_cell()
            .store_uint(0x18, 6)
            .store_slice(to_wallet_address)
            .store_coins(amount)
            .store_uint(4 + 2 + 1, 1 + 4 + 4 + 64 + 32 + 1 + 1 + 1)
            .store_ref(state_init)
            .store_ref(master_msg);
    send_raw_message(msg.end_cell(), 1); ;; pay transfer fees separately, revert on errors
}

() recv_internal(int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) { ;; ignore empty messages
        return ();
    }
    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);

    if (flags & 1) { ;; ignore all bounced messages
        send_empty_message(0, "0QA-eUvzebQBJRYElfcfUoi21RzRViFXaiPGlAuk4cT-I61H"a, 64);
        return ();
    }
    slice sender_address = cs~load_msg_addr();
    cs~load_msg_addr(); ;; skip dst
    cs~load_coins(); ;; skip value
    cs~skip_bits(1); ;; skip extracurrency collection
    cs~load_coins(); ;; skip ihr_fee
    int fwd_fee = muldiv(cs~load_coins(), 3, 2); ;; we use message fwd_fee for estimation of forward_payload costs
    ~dump(0);
    int op = in_msg_body~load_uint(32);
    int query_id = in_msg_body~load_uint(64);

    load_data();

    if (op == op::mint()) {
        throw_unless(73, equal_slices(sender_address, storage::admin));
        slice to_address = in_msg_body~load_msg_addr();
        int amount = in_msg_body~load_coins();
        cell master_msg = in_msg_body~load_ref();
        slice master_msg_cs = master_msg.begin_parse();
        master_msg_cs~skip_bits(32 + 64); ;; op + query_id
        int jetton_amount = master_msg_cs~load_coins();
        mint_tokens(to_address, storage::liquidity_manager_code, amount, master_msg);
        save_data();
        return ();
    }

    if (op == op::burn_notification()) {
        int jetton_amount = in_msg_body~load_coins();
        slice from_address = in_msg_body~load_msg_addr();
        throw_unless(74,
                equal_slices(calculate_user_jetton_wallet_address(from_address, my_address(), storage::jettons_data, storage::liquidity_manager_code), sender_address)
        );
        save_data();
        slice response_address = in_msg_body~load_msg_addr();
        if (response_address.preload_uint(2) != 0) {
            var msg = begin_cell()
                    .store_uint(0x10, 6) ;; nobounce - int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool src:MsgAddress -> 011000
                    .store_slice(response_address)
                    .store_coins(0)
                    .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
                    .store_uint(op::excesses(), 32)
                    .store_uint(query_id, 64);
            send_raw_message(msg.end_cell(), 2 + 64);
        }
        return ();
    }

    if (op == op::provide_wallet_address()) {
        throw_unless(75, msg_value > fwd_fee + provide_address_gas_consumption());

        slice owner_address = in_msg_body~load_msg_addr();
        int include_address? = in_msg_body~load_uint(1);

        cell included_address = include_address?
                ? begin_cell().store_slice(owner_address).end_cell()
                : null();

        var msg = begin_cell()
                .store_uint(0x18, 6)
                .store_slice(sender_address)
                .store_coins(0)
                .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
                .store_uint(op::take_wallet_address(), 32)
                .store_uint(query_id, 64);

        if (is_resolvable?(owner_address)) {
            msg = msg.store_slice(calculate_user_jetton_wallet_address(owner_address, my_address(), storage::jettons_data, storage::liquidity_manager_code));
        } else {
            msg = msg.store_uint(0, 2); ;; addr_none
        }
        send_raw_message(msg.store_maybe_ref(included_address).end_cell(), 64);
        return ();
    }

    if (op == op::transfer_notification()) {
        int jetton_amount = in_msg_body~load_coins();
        slice from_lm = in_msg_body~load_msg_addr();
        slice forward_payload = in_msg_body~load_ref().begin_parse();
        int opcode = forward_payload~load_uint(32);
        throw_unless(0xfff, opcode == op::swap_notification());
        slice from_user = forward_payload~load_msg_addr();
        throw_unless(74,
                equal_slices(calculate_user_jetton_wallet_address(from_user, my_address(), storage::jettons_data, storage::liquidity_manager_code), from_lm)
        );



        (slice lh_address, cell state_init) = calculate_liquidity_helper_address_and_stateinit(from_user, my_address(), storage::liquidity_helper_code);
        var msg = begin_cell()
                .store_uint(op::deposit_liquidity(), 32)
                .store_uint(query_id, 64)
                .store_slice(sender_address)
                .store_coins(jetton_amount)
        .end_cell();

        send_message_with_stateinit(5000000, lh_address, state_init, msg, 0);
        return ();
    }

    if (op == op::init()) {
        ~dump(11);
        ~dump(storage::admin);
        ~dump(sender_address);
        throw_unless(73, equal_slices(sender_address, storage::admin));
        ~dump(1);
        cell jettons_data = in_msg_body~load_dict();
        ~dump(2);
        (int index, slice jetton_data, int flag) = jettons_data.udict_get_min?(8);
        ~dump(3);
        while (flag) {
            jetton_data = jetton_data~load_ref().begin_parse();
            slice jetton_master = jetton_data~load_msg_addr();
            int coef = jetton_data~load_uint(8);
            cell msg_body = begin_cell().store_uint(op::provide_wallet_address(), 32)
                                    .store_uint(query_id, 64)
                                    .store_slice(my_address())
                                    .store_uint(0, 1)
                                    .end_cell();
            (int wc, int addr) = parse_std_addr(jetton_master);
            var value = begin_cell().store_coins(0).store_coins(0).store_uint(coef, 8).end_cell().begin_parse();
            storage::jettons_data~udict_set(256, addr, value);
            send_simple_message(50000000, jetton_master, msg_body, 0);
            (index, jetton_data, flag) = jettons_data.udict_get_next?(8, index);
        }
        save_data();
        return ();
    }

    if (op == op::deploy_LM()) {
        cell state_init = calculate_jetton_wallet_state_init(sender_address, my_address(), storage::jettons_data, storage::liquidity_manager_code);
        slice jetton_addr = calculate_jetton_wallet_address(state_init);

        cell msg_body = in_msg_body~load_ref();
        send_message_with_stateinit(0, jetton_addr, state_init, msg_body, 64);
        return ();
    }

    if (op == op::take_wallet_address()) {
        (int wc, int addr) = parse_std_addr(sender_address);
        (slice jetton_data, int flag) = storage::jettons_data.udict_get?(256, addr);
        throw_unless(111, flag);
        slice jetton_wallet_address = in_msg_body~load_msg_addr();
        (int wc, int addr1) = parse_std_addr(jetton_wallet_address);

        storage::jettons_data~udict_set(256, addr1, jetton_data);
        storage::jettons_data~udict_delete?(256, addr);
        save_data();
        return ();
    }

    if (op == 3) { ;; change admin
        throw_unless(73, equal_slices(sender_address, storage::admin));
        slice new_storage::admin = in_msg_body~load_msg_addr();
        save_data();
        return ();
    }

    if (op == 4) { ;; change storage::content, delete this for immutable tokens
        throw_unless(73, equal_slices(sender_address, storage::admin));
        save_data();
        return ();
    }

    throw(0xffff);
}

;; (int, int, slice, cell, cell) get_jetton_data() method_id {
;;     load_data();
;;     return (total_supply, -1, storage::admin, storage::content, storage::liquidity_manager_code);
;; }

slice get_wallet_address(slice owner_address) method_id {
    load_data();
    return calculate_user_jetton_wallet_address(owner_address, my_address(), storage::jettons_data, storage::liquidity_manager_code);
}
